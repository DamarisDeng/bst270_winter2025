chains = list()
for(m in 1:M){
pi_e_init = ye/ne + rnorm(1,sd = 0.1 * ye/ne)
pi_u_init = yu/nu + rnorm(1,sd = 0.1 * yu/nu)
chains[[m]] = MCMC_function(pi_e_init,pi_u_init,ye,ne,yu,nu)
}
for(m in 1:M){
cat("Acceptance rate for chain",m,"is:",chains[[m]]$accept_rate,"\n")
}
len = iters - burn_in
df.pie = data.frame(x = rep(1:len,5),
y = c(chains[[1]]$pi_e,chains[[2]]$pi_e,chains[[3]]$pi_e,chains[[4]]$pi_e,chains[[5]]$pi_e), groups = rep(c("Chain1","Chain2","Chain3","Chain4","Chain5"),each = len))
df.piu = data.frame(x = rep(1:len,5),
y = c(chains[[1]]$pi_u,chains[[2]]$pi_u,chains[[3]]$pi_u,chains[[4]]$pi_u,chains[[5]]$pi_u), groups = rep(c("Chain1","Chain2","Chain3","Chain4","Chain5"),each = len))
ggplot(data = df.pie,aes(x=x,y=y,color=groups)) + geom_line() +
labs(title = "Traceplot of pi_e for different chains",x = "iters (post burn-in)", y ="pi_e") +
theme_bw()
# MCMC Loop
MCMC_function = function(pi_e_init,pi_u_init,ye,ne,yu,nu,iters = 10000, burn_in = 2000){
theta_e_current <- log(pi_e_init/(1 - pi_e_init))
theta_u_current <- log(pi_u_init/(1 - pi_u_init))
# Storage
theta_e_samples <- numeric(iters)
theta_u_samples <- numeric(iters)
accept_count <- 0
log_post_current <- log_posterior(theta_e_current, theta_u_current, ye, ne, yu, nu)
for (iter in 1:iters) {
# Propose new values
theta_e_prop <- rnorm(1, mean = theta_e_current, sd = 0.15)
theta_u_prop <- rnorm(1, mean = theta_u_current, sd = 0.15)
# Compute proposed log-posterior for stability
log_post_prop <- log_posterior(theta_e_prop, theta_u_prop, ye, ne, yu, nu)
# Acceptance ratio
alpha <- exp(log_post_prop - log_post_current)
if (runif(1) < alpha) {
# Accept
theta_e_current <- theta_e_prop
theta_u_current <- theta_u_prop
log_post_current <- log_post_prop
accept_count <- accept_count + 1
}
# Store samples
theta_e_samples[iter] <- theta_e_current
theta_u_samples[iter] <- theta_u_current
}
accept_rate <- accept_count / iters
# Discard burn-in samples
keep_indices <- seq(from = burn_in+1, to = iters)
theta_e_kept <- theta_e_samples[keep_indices]
theta_u_kept <- theta_u_samples[keep_indices]
# Convert back to pi
pi_e_kept <- exp(theta_e_kept)/(1+exp(theta_e_kept))
pi_u_kept <- exp(theta_u_kept)/(1+exp(theta_u_kept))
out = list(pi_e = pi_e_kept, pi_u = pi_u_kept, accept_rate = accept_rate)
}
chains = list()
for(m in 1:M){
pi_e_init = ye/ne + rnorm(1,sd = 0.1 * ye/ne)
pi_u_init = yu/nu + rnorm(1,sd = 0.1 * yu/nu)
chains[[m]] = MCMC_function(pi_e_init,pi_u_init,ye,ne,yu,nu)
}
for(m in 1:M){
cat("Acceptance rate for chain",m,"is:",chains[[m]]$accept_rate,"\n")
}
len = iters - burn_in
df.pie = data.frame(x = rep(1:len,5),
y = c(chains[[1]]$pi_e,chains[[2]]$pi_e,chains[[3]]$pi_e,chains[[4]]$pi_e,chains[[5]]$pi_e), groups = rep(c("Chain1","Chain2","Chain3","Chain4","Chain5"),each = len))
df.piu = data.frame(x = rep(1:len,5),
y = c(chains[[1]]$pi_u,chains[[2]]$pi_u,chains[[3]]$pi_u,chains[[4]]$pi_u,chains[[5]]$pi_u), groups = rep(c("Chain1","Chain2","Chain3","Chain4","Chain5"),each = len))
ggplot(data = df.pie,aes(x=x,y=y,color=groups)) + geom_line() +
labs(title = "Traceplot of pi_e for different chains",x = "iters (post burn-in)", y ="pi_e") +
theme_bw()
ggplot(data = df.piu,aes(x=x,y=y,color=groups)) + geom_line() +
labs(title = "Traceplot of pi_u for different chains",x = "iters (post burn-in)", y ="pi_u") +
theme_bw()
# MCMC Loop
MCMC_function = function(pi_e_init,pi_u_init,ye,ne,yu,nu,iters = 10000, burn_in = 2000){
theta_e_current <- log(pi_e_init/(1 - pi_e_init))
theta_u_current <- log(pi_u_init/(1 - pi_u_init))
# Storage
theta_e_samples <- numeric(iters)
theta_u_samples <- numeric(iters)
accept_count <- 0
log_post_current <- log_posterior(theta_e_current, theta_u_current, ye, ne, yu, nu)
for (iter in 1:iters) {
# Propose new values
theta_e_prop <- rnorm(1, mean = theta_e_current, sd = 0.1)
theta_u_prop <- rnorm(1, mean = theta_u_current, sd = 0.1)
# Compute proposed log-posterior for stability
log_post_prop <- log_posterior(theta_e_prop, theta_u_prop, ye, ne, yu, nu)
# Acceptance ratio
alpha <- exp(log_post_prop - log_post_current)
if (runif(1) < alpha) {
# Accept
theta_e_current <- theta_e_prop
theta_u_current <- theta_u_prop
log_post_current <- log_post_prop
accept_count <- accept_count + 1
}
# Store samples
theta_e_samples[iter] <- theta_e_current
theta_u_samples[iter] <- theta_u_current
}
accept_rate <- accept_count / iters
# Discard burn-in samples
keep_indices <- seq(from = burn_in+1, to = iters)
theta_e_kept <- theta_e_samples[keep_indices]
theta_u_kept <- theta_u_samples[keep_indices]
# Convert back to pi
pi_e_kept <- exp(theta_e_kept)/(1+exp(theta_e_kept))
pi_u_kept <- exp(theta_u_kept)/(1+exp(theta_u_kept))
out = list(pi_e = pi_e_kept, pi_u = pi_u_kept, accept_rate = accept_rate)
}
chains = list()
for(m in 1:M){
pi_e_init = ye/ne + rnorm(1,sd = 0.1 * ye/ne)
pi_u_init = yu/nu + rnorm(1,sd = 0.1 * yu/nu)
chains[[m]] = MCMC_function(pi_e_init,pi_u_init,ye,ne,yu,nu)
}
for(m in 1:M){
cat("Acceptance rate for chain",m,"is:",chains[[m]]$accept_rate,"\n")
}
len = iters - burn_in
df.pie = data.frame(x = rep(1:len,5),
y = c(chains[[1]]$pi_e,chains[[2]]$pi_e,chains[[3]]$pi_e,chains[[4]]$pi_e,chains[[5]]$pi_e), groups = rep(c("Chain1","Chain2","Chain3","Chain4","Chain5"),each = len))
df.piu = data.frame(x = rep(1:len,5),
y = c(chains[[1]]$pi_u,chains[[2]]$pi_u,chains[[3]]$pi_u,chains[[4]]$pi_u,chains[[5]]$pi_u), groups = rep(c("Chain1","Chain2","Chain3","Chain4","Chain5"),each = len))
ggplot(data = df.pie,aes(x=x,y=y,color=groups)) + geom_line() +
labs(title = "Traceplot of pi_e for different chains",x = "iters (post burn-in)", y ="pi_e") +
theme_bw()
# MCMC Loop
MCMC_function = function(pi_e_init,pi_u_init,ye,ne,yu,nu,iters = 20000, burn_in = 5000){
theta_e_current <- log(pi_e_init/(1 - pi_e_init))
theta_u_current <- log(pi_u_init/(1 - pi_u_init))
# Storage
theta_e_samples <- numeric(iters)
theta_u_samples <- numeric(iters)
accept_count <- 0
log_post_current <- log_posterior(theta_e_current, theta_u_current, ye, ne, yu, nu)
for (iter in 1:iters) {
# Propose new values
theta_e_prop <- rnorm(1, mean = theta_e_current, sd = 0.12)
theta_u_prop <- rnorm(1, mean = theta_u_current, sd = 0.12)
# Compute proposed log-posterior for stability
log_post_prop <- log_posterior(theta_e_prop, theta_u_prop, ye, ne, yu, nu)
# Acceptance ratio
alpha <- exp(log_post_prop - log_post_current)
if (runif(1) < alpha) {
# Accept
theta_e_current <- theta_e_prop
theta_u_current <- theta_u_prop
log_post_current <- log_post_prop
accept_count <- accept_count + 1
}
# Store samples
theta_e_samples[iter] <- theta_e_current
theta_u_samples[iter] <- theta_u_current
}
accept_rate <- accept_count / iters
# Discard burn-in samples
keep_indices <- seq(from = burn_in+1, to = iters)
theta_e_kept <- theta_e_samples[keep_indices]
theta_u_kept <- theta_u_samples[keep_indices]
# Convert back to pi
pi_e_kept <- exp(theta_e_kept)/(1+exp(theta_e_kept))
pi_u_kept <- exp(theta_u_kept)/(1+exp(theta_u_kept))
out = list(pi_e = pi_e_kept, pi_u = pi_u_kept, accept_rate = accept_rate)
}
# Post-processing
set.seed(235)
M = 5
iters = 20000
burn_in = 5000
cat("Number of chains is:",M,"\n")
cat("Number of iterations in each chain:",iters,"\n")
cat("Burn-in:",burn_in,"\n")
chains = list()
for(m in 1:M){
pi_e_init = ye/ne + rnorm(1,sd = 0.1 * ye/ne)
pi_u_init = yu/nu + rnorm(1,sd = 0.1 * yu/nu)
chains[[m]] = MCMC_function(pi_e_init,pi_u_init,ye,ne,yu,nu,iters = iters,burn_in = burn_in)
}
for(m in 1:M){
cat("Acceptance rate for chain",m,"is:",chains[[m]]$accept_rate,"\n")
}
len = iters - burn_in
df.pie = data.frame(x = rep(1:len,5),
y = c(chains[[1]]$pi_e,chains[[2]]$pi_e,chains[[3]]$pi_e,chains[[4]]$pi_e,chains[[5]]$pi_e), groups = rep(c("Chain1","Chain2","Chain3","Chain4","Chain5"),each = len))
df.piu = data.frame(x = rep(1:len,5),
y = c(chains[[1]]$pi_u,chains[[2]]$pi_u,chains[[3]]$pi_u,chains[[4]]$pi_u,chains[[5]]$pi_u), groups = rep(c("Chain1","Chain2","Chain3","Chain4","Chain5"),each = len))
ggplot(data = df.pie,aes(x=x,y=y,color=groups)) + geom_line() +
labs(title = "Traceplot of pi_e for different chains",x = "iters (post burn-in)", y ="pi_e") +
theme_bw()
ggplot(data = df.piu,aes(x=x,y=y,color=groups)) + geom_line() +
labs(title = "Traceplot of pi_u for different chains",x = "iters (post burn-in)", y ="pi_u") +
theme_bw()
psrf_values = psrf(chains)
cat("\nPotential Scale Reduction Factor (PSR) for pi_e:\n")
print(psrf_values$psr_pie)
cat("\nPotential Scale Reduction Factor (PSR) for pi_u:\n")
print(psrf_values$psr_piu)
# MCMC Loop
MCMC_function = function(pi_e_init,pi_u_init,ye,ne,yu,nu,iters = 20000, burn_in = 5000){
theta_e_current <- log(pi_e_init/(1 - pi_e_init))
theta_u_current <- log(pi_u_init/(1 - pi_u_init))
# Storage
theta_e_samples <- numeric(iters)
theta_u_samples <- numeric(iters)
accept_count <- 0
log_post_current <- log_posterior(theta_e_current, theta_u_current, ye, ne, yu, nu)
for (iter in 1:iters) {
# Propose new values
theta_e_prop <- rnorm(1, mean = theta_e_current, sd = 0.5)
theta_u_prop <- rnorm(1, mean = theta_u_current, sd = 0.5)
# Compute proposed log-posterior for stability
log_post_prop <- log_posterior(theta_e_prop, theta_u_prop, ye, ne, yu, nu)
# Acceptance ratio
alpha <- exp(log_post_prop - log_post_current)
if (runif(1) < alpha) {
# Accept
theta_e_current <- theta_e_prop
theta_u_current <- theta_u_prop
log_post_current <- log_post_prop
accept_count <- accept_count + 1
}
# Store samples
theta_e_samples[iter] <- theta_e_current
theta_u_samples[iter] <- theta_u_current
}
accept_rate <- accept_count / iters
# Discard burn-in samples
keep_indices <- seq(from = burn_in+1, to = iters)
theta_e_kept <- theta_e_samples[keep_indices]
theta_u_kept <- theta_u_samples[keep_indices]
# Convert back to pi
pi_e_kept <- exp(theta_e_kept)/(1+exp(theta_e_kept))
pi_u_kept <- exp(theta_u_kept)/(1+exp(theta_u_kept))
out = list(pi_e = pi_e_kept, pi_u = pi_u_kept, accept_rate = accept_rate)
}
chains = list()
for(m in 1:M){
pi_e_init = ye/ne + rnorm(1,sd = 0.1 * ye/ne)
pi_u_init = yu/nu + rnorm(1,sd = 0.1 * yu/nu)
chains[[m]] = MCMC_function(pi_e_init,pi_u_init,ye,ne,yu,nu,iters = iters,burn_in = burn_in)
}
for(m in 1:M){
cat("Acceptance rate for chain",m,"is:",chains[[m]]$accept_rate,"\n")
}
len = iters - burn_in
df.pie = data.frame(x = rep(1:len,5),
y = c(chains[[1]]$pi_e,chains[[2]]$pi_e,chains[[3]]$pi_e,chains[[4]]$pi_e,chains[[5]]$pi_e), groups = rep(c("Chain1","Chain2","Chain3","Chain4","Chain5"),each = len))
df.piu = data.frame(x = rep(1:len,5),
y = c(chains[[1]]$pi_u,chains[[2]]$pi_u,chains[[3]]$pi_u,chains[[4]]$pi_u,chains[[5]]$pi_u), groups = rep(c("Chain1","Chain2","Chain3","Chain4","Chain5"),each = len))
ggplot(data = df.pie,aes(x=x,y=y,color=groups)) + geom_line() +
labs(title = "Traceplot of pi_e for different chains",x = "iters (post burn-in)", y ="pi_e") +
theme_bw()
ggplot(data = df.piu,aes(x=x,y=y,color=groups)) + geom_line() +
labs(title = "Traceplot of pi_u for different chains",x = "iters (post burn-in)", y ="pi_u") +
theme_bw()
psrf_values = psrf(chains)
cat("\nPotential Scale Reduction Factor (PSR) for pi_e:\n")
print(psrf_values$psr_pie)
cat("\nPotential Scale Reduction Factor (PSR) for pi_u:\n")
print(psrf_values$psr_piu)
# MCMC Loop
MCMC_function = function(pi_e_init,pi_u_init,ye,ne,yu,nu,iters = 20000, burn_in = 5000){
theta_e_current <- log(pi_e_init/(1 - pi_e_init))
theta_u_current <- log(pi_u_init/(1 - pi_u_init))
# Storage
theta_e_samples <- numeric(iters)
theta_u_samples <- numeric(iters)
accept_count <- 0
log_post_current <- log_posterior(theta_e_current, theta_u_current, ye, ne, yu, nu)
for (iter in 1:iters) {
# Propose new values
theta_e_prop <- rnorm(1, mean = theta_e_current, sd = 0.2)
theta_u_prop <- rnorm(1, mean = theta_u_current, sd = 0.1)
# Compute proposed log-posterior for stability
log_post_prop <- log_posterior(theta_e_prop, theta_u_prop, ye, ne, yu, nu)
# Acceptance ratio
alpha <- exp(log_post_prop - log_post_current)
if (runif(1) < alpha) {
# Accept
theta_e_current <- theta_e_prop
theta_u_current <- theta_u_prop
log_post_current <- log_post_prop
accept_count <- accept_count + 1
}
# Store samples
theta_e_samples[iter] <- theta_e_current
theta_u_samples[iter] <- theta_u_current
}
accept_rate <- accept_count / iters
# Discard burn-in samples
keep_indices <- seq(from = burn_in+1, to = iters)
theta_e_kept <- theta_e_samples[keep_indices]
theta_u_kept <- theta_u_samples[keep_indices]
# Convert back to pi
pi_e_kept <- exp(theta_e_kept)/(1+exp(theta_e_kept))
pi_u_kept <- exp(theta_u_kept)/(1+exp(theta_u_kept))
out = list(pi_e = pi_e_kept, pi_u = pi_u_kept, accept_rate = accept_rate)
}
# Post-processing
set.seed(235)
M = 5
iters = 20000
burn_in = 5000
cat("Number of chains is:",M,"\n")
cat("Number of iterations in each chain:",iters,"\n")
cat("Burn-in:",burn_in,"\n")
chains = list()
for(m in 1:M){
pi_e_init = ye/ne + rnorm(1,sd = 0.1 * ye/ne)
pi_u_init = yu/nu + rnorm(1,sd = 0.1 * yu/nu)
chains[[m]] = MCMC_function(pi_e_init,pi_u_init,ye,ne,yu,nu,iters = iters,burn_in = burn_in)
}
for(m in 1:M){
cat("Acceptance rate for chain",m,"is:",chains[[m]]$accept_rate,"\n")
}
len = iters - burn_in
df.pie = data.frame(x = rep(1:len,5),
y = c(chains[[1]]$pi_e,chains[[2]]$pi_e,chains[[3]]$pi_e,chains[[4]]$pi_e,chains[[5]]$pi_e), groups = rep(c("Chain1","Chain2","Chain3","Chain4","Chain5"),each = len))
df.piu = data.frame(x = rep(1:len,5),
y = c(chains[[1]]$pi_u,chains[[2]]$pi_u,chains[[3]]$pi_u,chains[[4]]$pi_u,chains[[5]]$pi_u), groups = rep(c("Chain1","Chain2","Chain3","Chain4","Chain5"),each = len))
ggplot(data = df.pie,aes(x=x,y=y,color=groups)) + geom_line() +
labs(title = "Traceplot of pi_e for different chains",x = "iters (post burn-in)", y ="pi_e") +
theme_bw()
ggplot(data = df.piu,aes(x=x,y=y,color=groups)) + geom_line() +
labs(title = "Traceplot of pi_u for different chains",x = "iters (post burn-in)", y ="pi_u") +
theme_bw()
psrf_values = psrf(chains)
cat("\nPotential Scale Reduction Factor (PSR) for pi_e:\n")
print(psrf_values$psr_pie)
cat("\nPotential Scale Reduction Factor (PSR) for pi_u:\n")
print(psrf_values$psr_piu)
load("/Users/keyao/Code/R_Code/BST270/ICPSR_04652/DS0001/04652-0001-Data.rda")
load("~/Code/R_Code/BST270/ICPSR_29282/DS0002/29282-0002-Data.rda")
load("~/Code/R_Code/BST270/ICPSR_04652/DS0001/04652-0001-Data.rda")
load("~/Code/R_Code/BST270/ICPSR_29282/DS0001/29282-0001-Data.rda")
knitr::opts_chunk$set(echo = TRUE)
data = inner_join(da04652.0001, da29282.0001, by = c("M2ID", "M2FAMNUM"),suffix = c('','.2'))
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(tidyverse)
library(ggplot2)
library(DT)
if (!require('devtools')) install.packages('devtools')
devtools::document()
getwd()
load('data/29282-0001-Data.rda')
data = inner_join(da04652.0001, da29282.0001, by = c("M2ID", "M2FAMNUM"),suffix = c('','.2'))
print(dim(data))
?inner_join
data$B4H26A
if (!require('devtools')) install.packages('devtools')
devtools::document()
setwd("~/Code/bst270_winter2025/group_project")
knitr::opts_chunk$set(echo = TRUE)
# filter and clean lipid measurement columns
source("filter_lipids.R")
Df_lipids <- Filter_lipids(data)
data$B4H21
View(data)
data$B1SE10F
data$B4H26
data$B4H26A
?ifelse
sum(is.na(data$B4H26))
df = data
df_exercise <- df|> mutate(B4H25=ifelse(grepl("Yes", B4H25), 1, 0))
df_bmi <- df|> filter(!is.na(B4PBMI))
df$B4H26A
exercise = df$B4H25
exercise
## Calculating the prudent diet score
#Grab fruit/veggie intake
fruit_veggie = df$B4H21
fruit_veggie
#Compute points
point_veggie = as.numeric(fruit_veggie == levels(fruit_veggie)[3] | fruit_veggie == levels(fruit_veggie)[4])
point_veggie
library(dplyr)
library(tidyverse)
library(ggplot2)
library(DT)
if (!require('devtools')) install.packages('devtools')
load('data/29282-0001-Data.rda')
load('data/04652-0001-Data.rda')
data = inner_join(da04652.0001, da29282.0001, by = c("M2ID", "M2FAMNUM"),suffix = c('','.2'))
print(dim(data))
data$B4H26 == "(1) Yes"
df = data
smoking_status = rep(NA,nrow(df))
smoking_status = rep(NA,nrow(df))
smoking_status[df$B4H26 == "(2) No"] = "(3) Never smoker"
smoking_status
df$B4H25
df$B4PBMI
require(tidyverse)
## Calculating the prudent diet score
#Grab fruit/veggie intake
fruit_veggie = df$B4H21
#Compute points
point_veggie = as.numeric(fruit_veggie == levels(fruit_veggie)[3] | fruit_veggie == levels(fruit_veggie)[4])
#grab grain intake
whole_grain = df$B4H22
#compute points
point_whole.grain = as.numeric(whole_grain == levels(whole_grain)[3] | whole_grain == levels(whole_grain)[4])
#grab fish intake
oily_fish = df$B4H23A
#compute points
point_fish = as.numeric(oily_fish == levels(oily_fish)[3] | oily_fish == levels(oily_fish)[4] |
oily_fish == levels(oily_fish)[5])
#grab lean meat intake
lean_meat = df$B4H23C
#compute points
point_lean.meat = as.numeric(lean_meat == levels(lean_meat)[3] | lean_meat == levels(lean_meat)[4] |
lean_meat == levels(lean_meat)[5])
#grab sugar bev intake
sugar_bev = df$B4H20
#compute points
point_sugar.bev = as.numeric(sugar_bev == levels(sugar_bev)[1])
#grab beef fat intake
beef_fat = df$B4H23B
#compute points
point_beef.fat = as.numeric(beef_fat == levels(beef_fat)[1] | beef_fat == levels(beef_fat)[2] |
beef_fat == levels(beef_fat)[3])
#grab fast food intake
fast_food = df$B4H24
#compute points
point_fast.food = as.numeric(fast_food == levels(fast_food)[1] | fast_food == levels(fast_food)[2])
#Compute total points across all categories
total_points = point_veggie + point_whole.grain + point_fish + point_lean.meat + point_sugar.bev + point_beef.fat + point_fast.food
smoking_status = rep(NA,nrow(df))
smoking_status[df$B4H26 == "(2) No"] = "(3) never smoker"
smoking_status[df$B4H26A == "(2) No"] = "(2) past smoker"
smoking_status[df$B4H26A == "(1) Yes"] = "(1) current smoker"
df$B4H36
out = data.frame(M2ID = df$M2ID, prudent_diet_score = total_points, smoking = smoking_status,
drinking = df$B4H36, exercise = df$B4H25, BMI = df$B4PBMI)
out = na.omit(out)
View(out)
?mutate
# filter and clean lipid measurement columns
source("filter_lipids.R")
Df_lipids <- Filter_lipids(data)
print(dim(Df_lipids))
?na.omit
out = data.frame(M2ID = df$M2ID, prudent_diet_score = total_points, smoking = smoking_status,
drinking = DrinksPerDay, exercise = df$B4H25, BMI = df$B4PBMI)
dInMo = 30
wksInMo = 4
# rename columns
colnames(df)[grep("B4H33", colnames(df))] = "bin"
colnames(df)[grep("B4H34", colnames(df))] = "often1"
colnames(df)[grep("B4H35", colnames(df))] = "often2"
colnames(df)[grep("B4H36", colnames(df))] = "onDrinkDays"
df$onDrinkDays = as.numeric(df$onDrinkDays)
look = df %>%
mutate(often2 = recode(often2, "(1) 3 Or 4 days/month" = 3.5, "(2) 1 Or 2 days/month" = 1.2, "(3) Less than one day/mo" = 0.5, "(4) Never drinks" = 0 ))
#table(df$bin, useNA = "always") # no missing data for bin var
df$bin = ifelse(df$bin == "(1) Yes", 1, 0)
# coding "Inapplicable as 1 because these are for people with 0 for "Past month, have you had at least one drink..." so multiplying bin and often1and2 will yield 0. And no truly missing data for often1, only in often2.
df$often1and2 = ifelse(df$bin == 0, 0,
ifelse(df$often1 == "(1) Everyday", dInMo,
ifelse(df$often1 == "(2) 5 Or 6 days/week", 5.5*wksInMo,
ifelse(df$often1 == "(3) 3 Or 4 days/week", 3.5*wksInMo,
ifelse(df$often1 == "(4) 1 Or 2 days/week", 1.5*wksInMo,
ifelse(df$often1 == "(5) Less than one day/week", df$often2,
ifelse(df$often1 == "(6) Never drinks", 0, 1)))))))
# coding "Inapplicable as 1 because these are for people with 0 for "Past month, have you had at least one drink..." or said "Never Drinks" or the like for the other variables so the final multiplication will yield 0. And there is no truly missing data for this variable https://www.icpsr.umich.edu/web/NACDA/studies/29282/datasets/0001/variables/B4H36?archive=NACDA
df$onDrinkDays = ifelse(is.na(df$onDrinkDays), 1, df$onDrinkDays)
# multiply
DrinksPerDay = df$bin * df$often1and2 * df$onDrinkDays /30
out = data.frame(M2ID = df$M2ID, prudent_diet_score = total_points, smoking = smoking_status,
drinking = DrinksPerDay, exercise = df$B4H25, BMI = df$B4PBMI)
out = na.omit(out)
#Return ID and Point Total
return(out)
View(out)
out = data.frame(M2ID = df$M2ID, prudent_diet_score = total_points, smoking_status = smoking_status,
drinks_per_day = DrinksPerDay, regular_exercise = df$B4H25, BMI = df$B4PBMI)
out = na.omit(out)
View(out)
load('data/29282-0001-Data.rda')
load('data/04652-0001-Data.rda')
data = inner_join(da04652.0001, da29282.0001, by = c("M2ID", "M2FAMNUM"),suffix = c('','.2'))
print(dim(data))
# filter optimism variables
source("filter_optimism.R")
Df_optimism <- Filter_optimism(data)
View(Df_optimism)
# filter and clean lipid measurement columns
source("filter_lipids.R")
Df_lipids <- Filter_lipids(data)
print(dim(Df_lipids))
source("filter_pathway.R")
# filter and clean lipid measurement columns
source("filter_lipids.R")
Df_lipids <- Filter_lipids(data)
print(dim(Df_lipids))
source("filter_pathway.R")
Df_pathway <- filter_pathway(data)
print(dim(Df_pathway))
# filter pathway varibales
View(Df_pathway)
View(Df_optimism)
View(Df_lipids)
# filter confounders
source("filter_confounders.R")
confounder_columns = Filter_confounders(data) ## 999 individuals left
View(confounder_columns)
